<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="LzMiracle">





<title>面试题目总结 | LzMiracle</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/fireworks.js"></script>
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">LzMiracle&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">LzMiracle&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">面试题目总结</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">LzMiracle</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十一月 9, 2020&nbsp;&nbsp;11:05:23</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="基础面试题"><a href="#基础面试题" class="headerlink" title="基础面试题"></a>基础面试题</h1><h2 id="1-禁用鼠标事件"><a href="#1-禁用鼠标事件" class="headerlink" title="1. 禁用鼠标事件"></a>1. 禁用鼠标事件</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.disabled</span> &#123;</span><br><span class="line">    <span class="attribute">pointer-events</span>: none;  <span class="comment">/*撤销禁用：pointer-events:auto;*/</span></span><br><span class="line">    <span class="attribute">cursor</span>: default;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-GET-HOST的区别"><a href="#2-GET-HOST的区别" class="headerlink" title="2.GET/HOST的区别"></a>2.GET/HOST的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET:</span><br><span class="line">1.请求可被缓存</span><br><span class="line">2.请求保留在浏览器历史记录中</span><br><span class="line">3.请求可被收藏为书签 </span><br><span class="line">4.请求不应在处理敏感数据时使用</span><br><span class="line">5.请求对数据有长度限制(2048字符),IE和Safari浏览器限制2k;Opera限制4k;Firefox、Chrome限制8k</span><br><span class="line">6.请求只应当用于取回数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST:</span><br><span class="line">1.请求不会被缓存</span><br><span class="line">2.请求不会保留在浏览器历史记录中</span><br><span class="line">3.不能被收藏为书签</span><br><span class="line">4.请求对数据没有长度限制</span><br></pre></td></tr></table></figure>

<h2 id="3-实现条纹网格的方式"><a href="#3-实现条纹网格的方式" class="headerlink" title="3.实现条纹网格的方式"></a>3.实现条纹网格的方式</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"row"</span>&gt;</span></span><br><span class="line"> 111   </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- even是奇数 odd是偶数 --&gt;</span></span><br><span class="line">.row:nth-child(even)&#123;  <span class="comment">&lt;!-- :nth-child 匹配其父元素中奇数个子元素 --&gt;</span></span><br><span class="line">	background:red;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">.row:nth-of-type(odd)&#123; <span class="comment">&lt;!-- :nth-of-type 匹配同类型中的第n个同级兄弟元素 --&gt;</span></span><br><span class="line">    background: #eee;</span><br><span class="line">&#125;</span><br><span class="line">或渐变实现</span><br><span class="line">.stripe-bg&#123;</span><br><span class="line">  height:20px;</span><br><span class="line">  background: beige;</span><br><span class="line">  background-size: 100%;</span><br><span class="line">  background-image: linear-gradient(0deg,red 50%,green 50%)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-js求平面两点之间的距离"><a href="#4-js求平面两点之间的距离" class="headerlink" title="4.js求平面两点之间的距离"></a>4.js求平面两点之间的距离</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据可以以数组方式存储，也可以是对象方式</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">x</span>:<span class="string">'6'</span>, <span class="attr">y</span>:<span class="number">10</span>&#125;</span><br><span class="line">    b = &#123;<span class="attr">x</span>: <span class="number">8</span>, <span class="attr">y</span>: <span class="number">20</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distant</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> dx = <span class="built_in">Number</span>(a.x) - <span class="built_in">Number</span>(b.x)</span><br><span class="line">        <span class="keyword">let</span> dy = <span class="built_in">Number</span>(a.y) - <span class="built_in">Number</span>(b.y)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(dx*dx + dy*dy, <span class="number">.5</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-css禁止用户选择"><a href="#5-css禁止用户选择" class="headerlink" title="5.css禁止用户选择"></a>5.css禁止用户选择</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">-webkit-touch-callout</span>: none;</span><br><span class="line">-webkit-user-select: none; //webkit浏览器</span><br><span class="line">-khtml-user-select: none; //早期浏览器</span><br><span class="line">-moz-user-select: none; //火狐</span><br><span class="line">-ms-user-select: none; //IE10</span><br><span class="line"><span class="selector-tag">user-select</span>: <span class="selector-tag">none</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-什么是CDN和CDN的好处"><a href="#6-什么是CDN和CDN的好处" class="headerlink" title="6.什么是CDN和CDN的好处"></a>6.什么是CDN和CDN的好处</h2><blockquote>
<p>CDN:CDN是将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景</p>
</blockquote>
<blockquote>
<p>好处</p>
<p> 1、多域名加载资源 一般情况下，浏览器都会对单个域名下的并发请求数（文件加载）进行限制，通常最多有4个，那么第5个加载项将会被阻塞，直到前面的某一个文件加载完毕。 因为CDN文件是存放在不同区域（不同IP）的，所以对浏览器来说是可以同时加载页面所需的所有文件（远不止4个），从而提高页面加载速度。</p>
<p>2、文件可能已经被加载过并保存有缓存 一些通用的js库或者是css样式库，如jQuery，在网络中的使用是非常普遍的。当一个用户在浏览你的某一个网页的时候，很有可能他已经通过你网站使用的CDN访问过了其他的某一个网站，恰巧这个网站同样也使用了jQuery，那么此时用户浏览器已经缓存有该jQuery文件（同IP的同名文件如果有缓存，浏览器会直接使用缓存文件，不会再进行加载），所以就不会再加载一次了，从而间接的提高了网站的访问速度</p>
<p>3、高效率 你的网站做的再NB也不会NB过百度NB过Google吧？一个好的CDNs会提供更高的效率，更低的网络延时和更小的丢包率。</p>
<p>4、分布式的数据中心 假如你的站点布置在北京，当一个香港或者更远的用户访问你的站点的时候，他的数据请求势必会很慢很慢。而CDNs则会让用户从离他最近的节点去加载所需的文件，所以加载速度提升就是理所当然的了。</p>
<p>5、使用情况分析 一般情况下CDNs提供商（如百度云加速）都会提供数据统计功能，可以了解更多关于用户访问自己网站的情况，可以根据统计数据对自己的站点适时适当的做出些许调整。</p>
<p>6、有效防止网站被攻击 一般情况下CDNs提供商也是会提供网站安全服务的</p>
</blockquote>
<h2 id="7-圣杯布局和双飞翼布局"><a href="#7-圣杯布局和双飞翼布局" class="headerlink" title="7.圣杯布局和双飞翼布局"></a>7.圣杯布局和双飞翼布局</h2><blockquote>
<p><a href="https://blog.csdn.net/wangchengiii/article/details/77926868" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h2 id="8-如何提高首页加载速度"><a href="#8-如何提高首页加载速度" class="headerlink" title="8.如何提高首页加载速度"></a>8.如何提高首页加载速度</h2><blockquote>
<p>1.js外联文件放到body底部，css外联文件放到head内 </p>
<p>2.http静态资源尽量用多个子域名 </p>
<p>3.服务器端提供html和http静态资源时最好开启gzip </p>
<p>4.在js,css,img等资源响应的http headers里设置expires,last-modified </p>
<p>5.尽量减少http requests的数量 </p>
<p>6.js/css/html/img资源压缩 </p>
<p>7.使用css spirtes，可以减少img请求次数</p>
<p> 8.大图使用lazyload懒加载 </p>
<p>9.避免404，减少外联js </p>
<p>10.减少cookie大小可以提高获得响应的时间</p>
<p> 11.减少dom elements的数量 </p>
<p>12.使用异步脚本，动态创建脚本</p>
</blockquote>
<h2 id="9-页面导入样式时，使用link和-import有什么区别？"><a href="#9-页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="9.页面导入样式时，使用link和@import有什么区别？"></a>9.页面导入样式时，使用link和@import有什么区别？</h2><blockquote>
<p>（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; </p>
<p>（2）页面被加载的时侯，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; （3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; </p>
<p>（4）link支持使用js控制DOM去改变样式，而@import不支持</p>
</blockquote>
<h2 id="10-简述一下你对HTML语义化的理解？"><a href="#10-简述一下你对HTML语义化的理解？" class="headerlink" title="10. 简述一下你对HTML语义化的理解？"></a>10. 简述一下你对HTML语义化的理解？</h2><blockquote>
<p>用正确的标签做正确的事情。 html语义化让页面的内容结构化，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>
</blockquote>
<h2 id="11-怎么实现路由转发"><a href="#11-怎么实现路由转发" class="headerlink" title="11.怎么实现路由转发"></a>11.怎么实现路由转发</h2><blockquote>
<p><a href="https://blog.csdn.net/jiandan1127/article/details/82592241" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h2 id="12-如何解决跨域问题"><a href="#12-如何解决跨域问题" class="headerlink" title="12.如何解决跨域问题?"></a>12.如何解决跨域问题?</h2><blockquote>
<p>jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</p>
<p><a href="https://blog.csdn.net/yup1212/article/details/87633272" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h2 id="13-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？"><a href="#13-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？" class="headerlink" title="13.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？"></a>13.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</h2><blockquote>
<ul>
<li><p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.</p>
</li>
<li><p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p>
</li>
<li><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p>
<p>浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}</p>
<p>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</p>
<p>渐进识别的方式，从总体中逐渐排除局部。</p>
<p>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p>
<p>css .bb{ background-color:red;/<em>所有识别</em>/ background-color:#00deff\9; /<em>IE6、7、8识别</em>/ +background-color:#a200ff;/<em>IE6、7识别</em>/ _background-color:#1e0bd1;/<em>IE6识别</em>/ }</p>
</li>
<li><p>IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性。 解决方法:统一通过getAttribute()获取自定义属性。</p>
</li>
<li><p>IE下,even对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。</p>
</li>
<li><p>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p>
</li>
<li><p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</p>
</li>
<li><p>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}</p>
</li>
</ul>
</blockquote>
<h2 id="14-什么是window对象-什么是document对象"><a href="#14-什么是window对象-什么是document对象" class="headerlink" title="14.什么是window对象? 什么是document对象?"></a>14.什么是window对象? 什么是document对象?</h2><blockquote>
<p>window对象是指浏览器打开的窗口。 document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。</p>
</blockquote>
<h2 id="15-页面重构怎么优化？"><a href="#15-页面重构怎么优化？" class="headerlink" title="15.页面重构怎么优化？"></a>15.页面重构怎么优化？</h2><blockquote>
<p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。</p>
<p>对于传统的网站来说重构通常是：表格(table)布局</p>
<p>改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面</p>
<p>减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中</p>
<p>压缩JS、CSS、image等前端资源(通常是由服务器来解决) 程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存</p>
</blockquote>
<h2 id="16-currentTarget和Target的区别"><a href="#16-currentTarget和Target的区别" class="headerlink" title="16.currentTarget和Target的区别"></a>16.currentTarget和Target的区别</h2><blockquote>
<p>target和currentTarget的区别是: target:触发事件的元素。currentTarget:事件绑定的元素</p>
</blockquote>
<h2 id="17-你有用过哪些前端性能优化的方法"><a href="#17-你有用过哪些前端性能优化的方法" class="headerlink" title="17.你有用过哪些前端性能优化的方法"></a>17.你有用过哪些前端性能优化的方法</h2><blockquote>
<p>（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器</p>
<p>（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</p>
<p>（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</p>
<p>（4） 当需要设置的样式很多时设置className而不是直接操作style。</p>
<p>（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</p>
<p>（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</p>
<p>（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。</p>
<p>（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。<br>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</p>
</blockquote>
<h2 id="18-一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"><a href="#18-一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）" class="headerlink" title="18.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"></a>18.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</h2><blockquote>
<p>1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;<br>2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;<br>3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;<br>4、进行HTTP协议会话，客户端发送报头(请求报头);<br>5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;<br>6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;<br>7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;<br>8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;<br>9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;<br>10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</p>
</blockquote>
<h2 id="19-ES6-代码转成-ES5-代码的实现思路是什么"><a href="#19-ES6-代码转成-ES5-代码的实现思路是什么" class="headerlink" title="19.ES6 代码转成 ES5 代码的实现思路是什么"></a>19.ES6 代码转成 ES5 代码的实现思路是什么</h2><blockquote>
<p>说到 ES6 代码转成 ES5 代码，我们肯定会想到 Babel。所以，我们可以参考 Babel 的实现方式。</p>
<p>那么 Babel 是如何把 ES6 转成 ES5 呢，其大致分为三步：</p>
<ul>
<li>将代码字符串解析成抽象语法树，即所谓的 AST</li>
<li>对 AST 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码 //抽象语法树(AST)</li>
<li>根据处理后的 AST 再生成代码字符串</li>
</ul>
</blockquote>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="1-浏览器内核-渲染引擎"><a href="#1-浏览器内核-渲染引擎" class="headerlink" title="1.浏览器内核(渲染引擎)"></a>1.浏览器内核(渲染引擎)</h2><blockquote>
<p>IE/360/搜狗浏览器: Trident </p>
<p>Chrome/Safari/Opera: WebKit(KHTML的一个开源的分支) (虽然我们称WebKit为浏览器内核，但不太适合直接称渲染引擎，因为WebKit本身主要是由两个引擎构成的，一个正是渲染引擎“WebCore”，另一个则是javascript解释引擎“JSCore”，它们均是从KDE的渲染引擎KHTML及javascript解释引擎KJS衍生而来。) (在13年发布的Chrome 28.0.1469.0版本开始，Chrome放弃Chromium引擎转而使用最新的Blink引擎（基于WebKit2——苹果公司于2010年推出的新的WebKit引擎），Blink对比上一代的引擎精简了代码、改善了DOM框架，也提升了安全性。) (为了减少研发成本，Opera在2013年2月宣布放弃Presto，转而跟随Chrome使用WebKit分支的Chromium引擎作为自家浏览器核心引擎)</p>
<p> Firefox/SeaMonkey: Gecko</p>
</blockquote>
<h2 id="2-浏览器渲染过程及优化建议"><a href="#2-浏览器渲染过程及优化建议" class="headerlink" title="2.浏览器渲染过程及优化建议"></a>2.浏览器渲染过程及优化建议</h2><blockquote>
<p>1）解析： 一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。 CSS，解析CSS会产生CSS规则树。 Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree. </p>
<p>2）渲染：浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。注意： Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。 CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。也就是所谓的Frame。 然后，计算每个Frame（也就是每个Element）的位置，这又叫layout和reflow过程。 </p>
<p>3）绘制：最后通过调用操作系统Native GUI的API绘制。</p>
</blockquote>
<blockquote>
<p>建议</p>
<p>1)减少reflow(重排、回流)和repaint(重绘) ，不要一条一条地修改DOM的样式。</p>
<p>2)预先定义好css的class，然后修改DOM的className。</p>
<p> 3)不要把DOM结点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性 </p>
<p>4）为动画的HTML元件使用fixed或absoulte的position，尽量使用transform，那么修改他们的CSS是不会reflow的 </p>
<p>5）尽量少使用table布局。因为可能很小的一个小改动会造成整个table的重新布局</p>
</blockquote>
<h2 id="3-请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#3-请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="3.请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>3.请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h2><blockquote>
<p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），会在浏览器和服务器间来回传递。 </p>
<p>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
<p>存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
<p>有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>
</blockquote>
<h2 id="4-检测浏览器版本版本有哪些方式？"><a href="#4-检测浏览器版本版本有哪些方式？" class="headerlink" title="4.检测浏览器版本版本有哪些方式？"></a>4.检测浏览器版本版本有哪些方式？</h2><blockquote>
<p>  功能检测、userAgent特征检测</p>
<p>  比如：navigator.userAgent<br>  //“Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36<br>    (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36”</p>
</blockquote>
<h2 id="5-列举IE与其他浏览器不一样的特性"><a href="#5-列举IE与其他浏览器不一样的特性" class="headerlink" title="5.列举IE与其他浏览器不一样的特性"></a>5.列举IE与其他浏览器不一样的特性</h2><blockquote>
<p>触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性；</p>
<p>获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性；</p>
<p>阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法；</p>
<p>停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()；</p>
</blockquote>
<h2 id="7-http请求状态码"><a href="#7-http请求状态码" class="headerlink" title="7.http请求状态码"></a>7.http请求状态码</h2><blockquote>
<p>1**(信息类)：表示接收到请求并且继续处理 </p>
<p>100——客户必须继续发出请求</p>
<p> 101——客户要求服务器根据请求转换HTTP协议版本</p>
<p>2**(响应成功)：表示动作被成功接收、理解和接受<br>200——表明该请求被成功地完成，所请求的资源发送回客户端<br>201——提示知道新文件的URL<br>202——接受和处理、但处理未完成<br>203——返回信息不确定或不完整<br>204——请求收到，但返回信息为空<br>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件<br>206——服务器已经完成了部分用户的GET请求</p>
<p>3**(重定向类)：为了完成指定的动作，必须接受进一步处理<br>300——请求的资源可在多处得到<br>301——本网页被永久性转移到另一个URL<br>302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。<br>303——建议客户访问其他URL或访问方式<br>304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用<br>305——请求的资源必须从服务器指定的地址得到<br>306——前一版本HTTP中使用的代码，现行版本中不再使用<br>307——申明请求的资源临时性删除</p>
<p>4**(客户端错误类)：请求包含错误语法或不能正确执行<br>400——客户端请求有语法错误，不能被服务器所理解<br>401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>HTTP 401.1 - 未授权：登录失败<br>&emsp;&emsp;HTTP 401.2 - 未授权：服务器配置问题导致登录失败<br>&emsp;&emsp;HTTP 401.3 - ACL 禁止访问资源<br>&emsp;&emsp;HTTP 401.4 - 未授权：授权被筛选器拒绝<br>HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败<br>402——保留有效ChargeTo头响应<br>403——禁止访问，服务器收到请求，但是拒绝提供服务<br>HTTP 403.1 禁止访问：禁止可执行访问<br>&emsp;&emsp;HTTP 403.2 - 禁止访问：禁止读访问<br>&emsp;&emsp;HTTP 403.3 - 禁止访问：禁止写访问<br>&emsp;&emsp;HTTP 403.4 - 禁止访问：要求 SSL<br>&emsp;&emsp;HTTP 403.5 - 禁止访问：要求 SSL 128<br>&emsp;&emsp;HTTP 403.6 - 禁止访问：IP 地址被拒绝<br>&emsp;&emsp;HTTP 403.7 - 禁止访问：要求客户证书<br>&emsp;&emsp;HTTP 403.8 - 禁止访问：禁止站点访问<br>&emsp;&emsp;HTTP 403.9 - 禁止访问：连接的用户过多<br>&emsp;&emsp;HTTP 403.10 - 禁止访问：配置无效<br>&emsp;&emsp;HTTP 403.11 - 禁止访问：密码更改<br>&emsp;&emsp;HTTP 403.12 - 禁止访问：映射器拒绝访问<br>&emsp;&emsp;HTTP 403.13 - 禁止访问：客户证书已被吊销<br>&emsp;&emsp;HTTP 403.15 - 禁止访问：客户访问许可过多<br>&emsp;&emsp;HTTP 403.16 - 禁止访问：客户证书不可信或者无效<br>HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效<br>404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL<br>405——用户在Request-Line字段定义的方法不允许<br>406——根据用户发送的Accept拖，请求资源不可访问<br>407——类似401，用户必须首先在代理服务器上得到授权<br>408——客户端没有在用户指定的饿时间内完成请求<br>409——对当前资源状态，请求不能完成<br>410——服务器上不再有此资源且无进一步的参考地址<br>411——服务器拒绝用户定义的Content-Length属性请求<br>412——一个或多个请求头字段在当前请求中错误<br>413——请求的资源大于服务器允许的大小<br>414——请求的资源URL长于服务器允许的长度<br>415——请求资源不支持请求项目格式<br>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段<br>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</p>
<p>5**(服务端错误类)：服务器不能正确执行一个正确的请求<br>HTTP 500 - 服务器遇到错误，无法完成请求<br>&emsp;&emsp;HTTP 500.100 - 内部服务器错误 - ASP 错误<br>&emsp;&emsp;HTTP 500-11 服务器关闭<br>&emsp;&emsp;HTTP 500-12 应用程序重新启动<br>&emsp;&emsp;HTTP 500-13 - 服务器太忙<br>&emsp;&emsp;HTTP 500-14 - 应用程序无效<br>&emsp;&emsp;HTTP 500-15 - 不允许请求 global.asa<br>&emsp;&emsp;Error 501 - 未实现<br>HTTP 502 - 网关错误<br>HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</p>
</blockquote>
<h2 id="8-Http2的多路复用"><a href="#8-Http2的多路复用" class="headerlink" title="8.Http2的多路复用"></a>8.Http2的多路复用</h2><blockquote>
<p>在 HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：</p>
<ul>
<li>第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）</li>
<li>第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。</li>
</ul>
<p>HTTP/2的多路复用就是为了解决上述的两个性能问题。 在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能</p>
</blockquote>
<h2 id="9-TCP三次握手和四次挥手"><a href="#9-TCP三次握手和四次挥手" class="headerlink" title="9.TCP三次握手和四次挥手"></a>9.TCP三次握手和四次挥手</h2><p><img src="https://user-images.githubusercontent.com/34148615/53062591-3d846300-34fc-11e9-8d0f-4063d9ff3398.png" alt="image"></p>
<h3 id="一、三次握手讲解"><a href="#一、三次握手讲解" class="headerlink" title="一、三次握手讲解"></a>一、三次握手讲解</h3><ol>
<li>客户端发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，服务器由SYN=1知道客户端要求建立联机（客户端：我要连接你）</li>
<li>服务器收到请求后要确认联机信息，向A发送ack number=(客户端的seq+1),syn=1,ack=1,随机产生seq=7654321的包（服务器：好的，你来连吧）</li>
<li>客户端收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，客户端会再发送ack number=(服务器的seq+1),ack=1，服务器收到后确认seq值与ack=1则连接建立成功。（客户端：好的，我来了）</li>
</ol>
<h3 id="二、为什么http建立连接需要三次握手，不是两次或四次"><a href="#二、为什么http建立连接需要三次握手，不是两次或四次" class="headerlink" title="二、为什么http建立连接需要三次握手，不是两次或四次?"></a>二、为什么http建立连接需要三次握手，不是两次或四次?</h3><p><strong>答：三次是最少的安全次数，两次不安全，四次浪费资源；</strong></p>
<h3 id="三、TCP关闭连接过程"><a href="#三、TCP关闭连接过程" class="headerlink" title="三、TCP关闭连接过程"></a>三、TCP关闭连接过程</h3><ol>
<li>Client向Server发送FIN包，表示Client主动要关闭连接，然后进入FIN_WAIT_1状态，等待Server返回ACK包。此后Client不能再向Server发送数据，但能读取数据。</li>
<li>Server收到FIN包后向Client发送ACK包，然后进入CLOSE_WAIT状态，此后Server不能再读取数据，但可以继续向Client发送数据。</li>
<li>Client收到Server返回的ACK包后进入FIN_WAIT_2状态，等待Server发送FIN包。</li>
<li>Server完成数据的发送后，将FIN包发送给Client，然后进入LAST_ACK状态，等待Client返回ACK包，此后Server既不能读取数据，也不能发送数据。</li>
<li>Client收到FIN包后向Server发送ACK包，然后进入TIME_WAIT状态，接着等待足够长的时间（2MSL）以确保Server接收到ACK包，最后回到CLOSED状态，释放网络资源。</li>
<li>Server收到Client返回的ACK包后便回到CLOSED状态，释放网络资源。</li>
</ol>
<h3 id="四、为什么要四次挥手？"><a href="#四、为什么要四次挥手？" class="headerlink" title="四、为什么要四次挥手？"></a>四、为什么要四次挥手？</h3><p>TCP是全双工信道，何为全双工就是客户端与服务端建立两条通道，通道1:客户端的输出连接服务端的输入；通道2:客户端的输入连接服务端的输出。两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。所以关闭双通道的时候就是这样：</p>
<p>客户端：我要关闭输入通道了。 服务端：好的，你关闭吧，我这边也关闭这个通道。</p>
<p>服务端：我也要关闭输入通道了。 客户端：好的你关闭吧，我也把这个通道关闭。</p>
<h2 id="10-HTTP与HTTPS"><a href="#10-HTTP与HTTPS" class="headerlink" title="10.HTTP与HTTPS"></a>10.HTTP与HTTPS</h2><blockquote>
<p>什么是HTTP?</p>
<p>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法</p>
<p>什么是HTTPS？</p>
<p>《图解HTTP》这本书中曾提过HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。<br>PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分.</p>
</blockquote>
<h3 id="HTTP-VS-HTTPS"><a href="#HTTP-VS-HTTPS" class="headerlink" title="HTTP VS HTTPS"></a>HTTP VS HTTPS</h3><blockquote>
<p>HTTP特点：</p>
<p>无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作<br>无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。<br>基于请求和响应：基本的特性，由客户端发起请求，服务端响应<br>简单快速、灵活<br>通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</p>
<p>HTTPS特点：</p>
<p>基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护</p>
<p>内容加密：采用混合加密技术，中间者无法直接查看明文内容<br>验证身份：通过证书认证客户端访问的是自己的服务器<br>保护数据完整性：防止传输的内容被中间人冒充或者篡改</p>
<p><strong>混合加密：</strong>结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。</p>
<p><strong>数字摘要：</strong>通过单向hash函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。</p>
<p><strong>数字签名技术：</strong>数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术。</p>
<p>1、HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)</p>
<p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p>
<p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p>
</blockquote>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="1-数组去重"><a href="#1-数组去重" class="headerlink" title="1.数组去重"></a>1.数组去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// indexOf实现</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> current = array[i];</span><br><span class="line">        <span class="keyword">if</span> (res.indexOf(current) === <span class="number">-1</span>) &#123;</span><br><span class="line">            res.push(current)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序后去重</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">var</span> sortedArray = array.concat().sort();</span><br><span class="line">    <span class="keyword">var</span> seen;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = sortedArray.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果是第一个元素或者相邻的元素不相同</span></span><br><span class="line">        <span class="keyword">if</span> (!i || seen !== sortedArray[i]) &#123;</span><br><span class="line">            res.push(sortedArray[i])</span><br><span class="line">        &#125;</span><br><span class="line">        seen = sortedArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array));</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter实现</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.indexOf(item) === index;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(array));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序去重</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.concat().sort().filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !index || item !== array[index - <span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(array));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object键值对</span></span><br><span class="line"><span class="keyword">var</span> array = [&#123;<span class="attr">value</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">value</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item))</span><br><span class="line">        <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item)) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item)] = <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array)); <span class="comment">// [&#123;value: 1&#125;, &#123;value: 2&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 Set实现</span></span><br><span class="line"><span class="keyword">var</span> unique = <span class="function">(<span class="params">a</span>) =&gt;</span> [...new <span class="built_in">Set</span>(a)]</span><br></pre></td></tr></table></figure>

<h2 id="2-数组根据其中某个键值分类合并"><a href="#2-数组根据其中某个键值分类合并" class="headerlink" title="2.数组根据其中某个键值分类合并"></a>2.数组根据其中某个键值分类合并</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr=[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"color"</span>: <span class="string">"red"</span>,</span><br><span class="line">        <span class="string">"iconName"</span>: <span class="string">"class1"</span>,</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"菜单一"</span>,</span><br><span class="line">        <span class="string">"styleName"</span>: <span class="string">"分类名称1"</span>,</span><br><span class="line">        <span class="string">"url"</span>: <span class="string">"index1"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"color"</span>: <span class="string">"red"</span>,</span><br><span class="line">        <span class="string">"iconName"</span>: <span class="string">"calss2"</span>,</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"菜单二"</span>,</span><br><span class="line">        <span class="string">"styleName"</span>: <span class="string">"分类名称2"</span>,</span><br><span class="line">        <span class="string">"url"</span>: <span class="string">"index2"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"color"</span>: <span class="string">"blue"</span>,</span><br><span class="line">        <span class="string">"iconName"</span>: <span class="string">"calss3"</span>,</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"菜单三"</span>,</span><br><span class="line">        <span class="string">"styleName"</span>: <span class="string">"分类名称3"</span>,</span><br><span class="line">        <span class="string">"url"</span>: <span class="string">"index3"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ];</span><br><span class="line"><span class="keyword">var</span> map = &#123;&#125;,dest = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> ai = arr[i];</span><br><span class="line">    <span class="keyword">if</span>(!map[ai.styleName])&#123;</span><br><span class="line">        dest.push(&#123;</span><br><span class="line">            styleName: ai.styleName,</span><br><span class="line">            data: [ai]</span><br><span class="line">        &#125;);</span><br><span class="line">        map[ai.styleName] = ai;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; dest.length; j++)&#123;</span><br><span class="line">            <span class="keyword">var</span> dj = dest[j];</span><br><span class="line">            <span class="keyword">if</span>(dj.styleName == ai.styleName)&#123;</span><br><span class="line">                dj.data.push(ai);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-正则表达式匹配手机号"><a href="#3-正则表达式匹配手机号" class="headerlink" title="3.正则表达式匹配手机号"></a>3.正则表达式匹配手机号</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPhone</span>(<span class="params">phone</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="regexp">/^1[345678]\d&#123;9&#125;$/</span>.test(phone)))&#123;</span><br><span class="line">        alert(<span class="string">"手机号码有误，请重填"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-如何将浮点数点左边的数每三位添加一个逗号，如12000000-11转化为『12-000-000-11』"><a href="#4-如何将浮点数点左边的数每三位添加一个逗号，如12000000-11转化为『12-000-000-11』" class="headerlink" title="4.如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?"></a>4.如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commafy</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> num.toString().replace(<span class="regexp">/(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="string">","</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-邮箱验证"><a href="#5-邮箱验证" class="headerlink" title="5.邮箱验证"></a>5.邮箱验证</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/^([A-Za-z0-9_\-\.\u4e00-\u9fa5])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,8&#125;)$/</span>;</span><br></pre></td></tr></table></figure>

<h2 id="6-slice-、splice和contact-数组操作方法"><a href="#6-slice-、splice和contact-数组操作方法" class="headerlink" title="6.slice 、splice和contact 数组操作方法"></a>6.slice 、splice和contact 数组操作方法</h2><blockquote>
<p>slice是指定在一个数组中的元素创建一个新的数组，即原数组不会变 //截取数组<br>splice是JS中数组功能最强大的方法，它能够实现对数组元素的删除、插入、替换操作，返回值为被操作的值。<br>splice删除：color.splice(1,2) （删除color中的1、2两项）；<br>splice插入：color.splice(1,0,’brown’,’pink’) （在color键值为1的元素前插入两个值）；<br>splice替换：color.splice(1,2,’brown’,’pink’)  （在color中替换1、2元素）；</p>
<p>concat() 方法用于连接两个或多个数组。此方法返回一个新数组，不改变原来的数组</p>
</blockquote>
<h2 id="7-JS实现sort方法"><a href="#7-JS实现sort方法" class="headerlink" title="7.JS实现sort方法"></a>7.JS实现sort方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> t; </span><br><span class="line">fn=fn||<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x-y&#125;;  <span class="comment">//升序 y-x降序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++)&#123;  </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j=i;j&lt;<span class="keyword">this</span>.length;j++)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(fn(<span class="keyword">this</span>[i],<span class="keyword">this</span>[j])&gt;<span class="number">0</span>)&#123;  </span><br><span class="line">          t=<span class="keyword">this</span>[i];  </span><br><span class="line">          <span class="keyword">this</span>[i]=<span class="keyword">this</span>[j];  </span><br><span class="line">          <span class="keyword">this</span>[j]=t;  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="1-HTML5的新特性"><a href="#1-HTML5的新特性" class="headerlink" title="1.HTML5的新特性"></a>1.HTML5的新特性</h2><blockquote>
<p>一、语义标签</p>
<p>二、增强型表单</p>
<p>三、视频和音频</p>
<p>四、Canvas绘图</p>
<p>五、SVG绘图</p>
<p>六、地理定位</p>
<p>七、拖放API</p>
<p>八、WebWorker</p>
<p>九、WebStorage</p>
<p>十、WebSocket</p>
<p><a href="https://www.cnblogs.com/binguo666/p/10928907.html" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h2 id="2-iframe有那些缺点？"><a href="#2-iframe有那些缺点？" class="headerlink" title="2. iframe有那些缺点？"></a>2. iframe有那些缺点？</h2><blockquote>
<p>什么是iframe   <a href="https://zhuanlan.zhihu.com/p/143410277" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/143410277</a></p>
</blockquote>
<blockquote>
<p>iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO; </p>
<p>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 </p>
<p>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题。</p>
</blockquote>
<h2 id="3-canvas和svg区别"><a href="#3-canvas和svg区别" class="headerlink" title="3.canvas和svg区别"></a>3.canvas和svg区别</h2><blockquote>
<p>1.从图像类别区分，Canvas是基于像素的位图，而SVG却是基于矢量图形。可以简单的把两者的区别看成photoshop与illustrator的区别。</p>
<p> 2.从结构上说，Canvas没有图层的概念，所有的修改整个画布都要重新渲染，而SVG则可以对单独的标签进行修改。</p>
<p> 3.从操作对象上说，Canvas是基于HTML canvas标签，通过宿主提供的Javascript API对整个画布进行操作的，而SVG则是基于XML元素的。</p>
<p> 4.从功能上讲，SVG发布日期较早，所以功能相对Canvas比较完善。</p>
<p> 5.关于动画，Canvas更适合做基于位图的动画，而SVG则适合图表的展示。</p>
<p> 6.从搜索引擎角度分析，由于svg是有大量标签组成，所以可以通过给标签添加属性，便于爬虫搜索</p>
</blockquote>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="1-css的三大特性"><a href="#1-css的三大特性" class="headerlink" title="1.css的三大特性"></a>1.css的三大特性</h2><blockquote>
<p>CSS的三个特性是指层叠性、继承性以及优先级</p>
<p><a href="https://zhuanlan.zhihu.com/p/145152991" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h2 id="2-css3的新增特性"><a href="#2-css3的新增特性" class="headerlink" title="2.css3的新增特性"></a>2.css3的新增特性</h2><blockquote>
<ul>
<li>过度（transiton）</li>
<li>动画（animation）</li>
<li>形状转换</li>
</ul>
<ol>
<li>transform:适用于2D或3D转换的元素</li>
<li>transform-origin：转换元素的位置（围绕那个点进行转换）。默认(x,y,z)：(50%,50%,0)）</li>
</ol>
<ul>
<li>选择器<ul>
<li>参考 <a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/cssref/css_selectors.asp</a> （w3c参考）</li>
</ul>
</li>
<li>阴影（box-shadow）</li>
<li>边框（box-border）<ul>
<li>border-radius（边框圆角）</li>
<li>border-image（边框图片）</li>
</ul>
</li>
<li>反射<ul>
<li>倒影（reflect）</li>
</ul>
</li>
<li>颜色（提供了rgba和hsla的方法来显示颜色）</li>
<li>渐变</li>
<li>滤镜（filter）</li>
<li>布局<ul>
<li>flex弹性布局</li>
<li>grid栅格化布局</li>
<li>column-count多列布局</li>
</ul>
</li>
<li>盒模型</li>
<li>媒体查询（一般用来做自适应布局，与rem布局结合使用可以有巧妙地效果）</li>
</ul>
</blockquote>
<h2 id="3-CSS复合选择器"><a href="#3-CSS复合选择器" class="headerlink" title="3.CSS复合选择器"></a>3.CSS复合选择器</h2><table>
<thead>
<tr>
<th align="center">选择器</th>
<th align="center">作用</th>
<th align="center">特征</th>
<th align="center">使用情况</th>
<th align="center">隔开符号及用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">后代选择器</td>
<td align="center">用来选择元素后代</td>
<td align="center">是选择所有的子孙后代</td>
<td align="center">较多</td>
<td align="center">符号是<strong>空格</strong> .nav a</td>
</tr>
<tr>
<td align="center">子代选择器</td>
<td align="center">选择 最近一级元素</td>
<td align="center">只选亲儿子</td>
<td align="center">较少</td>
<td align="center">符号是<strong>&gt;</strong> .nav&gt;p</td>
</tr>
<tr>
<td align="center">交集选择器</td>
<td align="center">选择两个标签交集的部分</td>
<td align="center">既是 又是</td>
<td align="center">较少</td>
<td align="center"><strong>没有符号</strong> p.one</td>
</tr>
<tr>
<td align="center">并集选择器</td>
<td align="center">选择某些相同样式的选择器</td>
<td align="center">可以用于集体声明</td>
<td align="center">较多</td>
<td align="center">符号是<strong>逗号</strong> .nav, .header</td>
</tr>
<tr>
<td align="center">链接伪类选择器</td>
<td align="center">给链接更改状态</td>
<td align="center"></td>
<td align="center">较多</td>
<td align="center">重点记住 a{} 和 a:hover 实际开发的写法</td>
</tr>
</tbody></table>
<h2 id="4-解决高度塌陷"><a href="#4-解决高度塌陷" class="headerlink" title="4.解决高度塌陷"></a>4.解决高度塌陷</h2><blockquote>
<ol>
<li>给父级元素添加高度<br>优点：解决简单<br>缺点：就不能做到宽高自适应了</li>
</ol>
<ol start="2">
<li>在出现高度塌陷的父级元素设置overflow:hidden<br>优点：可以解决高度塌陷并且能做到自适应，好理解<br>缺点：超出当前父级元素的盒子都会被隐藏掉</li>
</ol>
<ol start="3">
<li>在最后一个盒子添加标签div，设置解决高度塌陷的样式<br>默认样式：clear：both 清除both 所以 left/right<br>清除浮动的原理：清除浮动元素预留下来的空间，为了放心一个浮动元素，清除了上方预留空间，所以可以解决高度塌陷<br>优点：出现高度塌陷的地方加一个标签即可<br>缺点：添加盒子，出现一些不必要的布局结构，代码冗余</li>
</ol>
<ol start="4">
<li>万能清楚法 – 不好理解,会用就行<br>在当前出现高度塌陷的元素上添加类名 clear-fix<br>clear-fix::after{<br>content:””;<br>width:100%;<br>height:0;<br>display:block;<br>clear:both;<br>overflow:hidden;<br>visibility:hidden;<br>}<br>优点：清除方便<br>缺点：代码多，难理解</li>
</ol>
</blockquote>
<h2 id="5-介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><a href="#5-介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？" class="headerlink" title="5.介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"></a>5.介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h2><blockquote>
<p>CSS盒子模型：由四个属性组成的外边距(margin)、内边距(padding)、边界(border)、内容区(width和height);</p>
<p>（1）有两种， IE 盒子模型、W3C 盒子模型</p>
<p>（2）区别:</p>
<p>​         标准的css盒子模型宽高就是内容区宽高；</p>
<p>　　低端IE css盒子模型宽高 内边距﹢边界﹢内容区；</p>
</blockquote>
<h2 id="6-position的值relative和absolute定位原点是？"><a href="#6-position的值relative和absolute定位原点是？" class="headerlink" title="6.position的值relative和absolute定位原点是？"></a>6.position的值relative和absolute定位原点是？</h2><blockquote>
<p>absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。</p>
<p> fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。</p>
<p> relative 生成相对定位的元素，相对于其正常位置进行定位。</p>
<p> static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 inherit 规定从父元素继承 position 属性的值。</p>
</blockquote>
<h2 id="7-CSS优化、提高性能的方法有哪些？"><a href="#7-CSS优化、提高性能的方法有哪些？" class="headerlink" title="7.CSS优化、提高性能的方法有哪些？"></a>7.CSS优化、提高性能的方法有哪些？</h2><blockquote>
<p>关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）； 如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）； 提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性; 使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）；</p>
</blockquote>
<h2 id="8-如何修改chrome记住密码后自动填充表单的黄色背景-？"><a href="#8-如何修改chrome记住密码后自动填充表单的黄色背景-？" class="headerlink" title="8.如何修改chrome记住密码后自动填充表单的黄色背景 ？"></a>8.如何修改chrome记住密码后自动填充表单的黄色背景 ？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:-webkit-autofill</span>, <span class="selector-tag">textarea</span><span class="selector-pseudo">:-webkit-autofill</span>, <span class="selector-tag">select</span><span class="selector-pseudo">:-webkit-autofill</span> &#123;</span><br><span class="line">   <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">250</span>, <span class="number">255</span>, <span class="number">189</span>); <span class="comment">/* #FAFFBD; */</span></span><br><span class="line">   <span class="attribute">background-image</span>: none;</span><br><span class="line">   <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-让页面里的字体变清晰，变细用CSS怎么做？"><a href="#9-让页面里的字体变清晰，变细用CSS怎么做？" class="headerlink" title="9.让页面里的字体变清晰，变细用CSS怎么做？"></a>9.让页面里的字体变清晰，变细用CSS怎么做？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-font-smoothing: antialiased;</span><br></pre></td></tr></table></figure>

<h2 id="10-开启硬件加速"><a href="#10-开启硬件加速" class="headerlink" title="10.开启硬件加速"></a>10.开启硬件加速</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//目前，像Chrome/Filefox/Safari/IE9+以及最新版本Opera都支持硬件加速，当检测到某个DOM元素应用了某些CSS规则时就会自动开启，从而解决页面闪白，保证动画流畅。</span><br><span class="line"><span class="selector-class">.css</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-移动端html标签几个体验优化"><a href="#11-移动端html标签几个体验优化" class="headerlink" title="11.移动端html标签几个体验优化"></a>11.移动端html标签几个体验优化</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">overflow</span>: hidden;<span class="comment">/*手机上写overflow-x:hidden;会有兼容性问题，如果子级如果是绝对定位有运动到屏幕外的话ios7系统会出现留白*/</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">-webkit-overflow-scrolling</span>:touch;<span class="comment">/*流畅滚动,ios7下会有滑一下滑不动的情况，所以需要写上*/</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">position</span>:realtive;<span class="comment">/*直接子级如果是绝对定位有运动到屏幕外的话，会出现留白*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-手机上的多行省略"><a href="#12-手机上的多行省略" class="headerlink" title="12.手机上的多行省略"></a>12.手机上的多行省略</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.overflow-hidden</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: box <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="attribute">-webkit-box-orient</span>: vertical;</span><br><span class="line">    <span class="attribute">-webkit-line-clamp</span>: <span class="number">4</span>;<span class="comment">/*第几行出现省略号*/</span></span><br><span class="line">    <span class="comment">/*text-align:justify;不能和溢出隐藏的代码一起写，会有bug*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-长时间按住页面闪退"><a href="#13-长时间按住页面闪退" class="headerlink" title="13.长时间按住页面闪退"></a>13.长时间按住页面闪退</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">    -webkit-touch-callout: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-改变输入框内提示文字颜色"><a href="#14-改变输入框内提示文字颜色" class="headerlink" title="14.改变输入框内提示文字颜色"></a>14.改变输入框内提示文字颜色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-input-placeholder &#123; &#x2F;* WebKit browsers *&#x2F;</span><br><span class="line">    color: #999; &#125;</span><br><span class="line">:-moz-placeholder &#123; &#x2F;* Mozilla Firefox 4 to 18 *&#x2F;</span><br><span class="line">    color: #999; &#125;</span><br><span class="line">::-moz-placeholder &#123; &#x2F;* Mozilla Firefox 19+ *&#x2F;</span><br><span class="line">    color: #999; &#125;</span><br><span class="line">:-ms-input-placeholder &#123; &#x2F;* Internet Explorer 10+ *&#x2F;</span><br><span class="line">    color: #999; &#125;</span><br><span class="line">input:focus::-webkit-input-placeholder&#123; color:#999; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-消除transtration闪屏"><a href="#15-消除transtration闪屏" class="headerlink" title="15.消除transtration闪屏"></a>15.消除transtration闪屏</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">消除<span class="selector-tag">transition</span>闪屏</span><br><span class="line"><span class="selector-class">.css</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">    <span class="attribute">-webkit-backface-visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">-webkit-perspective</span>: <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-BFC"><a href="#16-BFC" class="headerlink" title="16.BFC"></a>16.BFC</h2><h3 id="1-BFC概念"><a href="#1-BFC概念" class="headerlink" title="1.BFC概念"></a>1.BFC概念</h3><blockquote>
<p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流</p>
<p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性</p>
</blockquote>
<h3 id="2-触发BFC条件"><a href="#2-触发BFC条件" class="headerlink" title="2.触发BFC条件"></a>2.触发BFC条件</h3><blockquote>
<p>只要元素满足下面任一条件即可触发 BFC 特性：</p>
<ul>
<li>body 根元素</li>
<li>浮动元素：float 除 none 以外的值</li>
<li>绝对定位元素：position (absolute、fixed)</li>
<li>display 为 inline-block、table-cells、flex</li>
<li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li>
</ul>
</blockquote>
<h3 id="3-BFC-特性及应用"><a href="#3-BFC-特性及应用" class="headerlink" title="3.BFC 特性及应用"></a>3.BFC 特性及应用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 同一个 BFC 下外边距会发生折叠</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">div&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: lightblue;</span><br><span class="line">    margin: 100px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</span><br><span class="line">首先这不是 CSS 的 bug，我们可以理解为一种规范，**如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_720w.png" alt="img"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2.BFC 可以包含浮动的元素（清除浮动）</span><br><span class="line">我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"border: 1px solid #000;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100px;height: 100px;background: #eee;float: left;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_720w.png" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png" alt="img"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3.BFC 可以阻止元素被浮动元素覆盖</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 100px;width: 100px;float: left;background: lightblue"</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 200px; height: 200px;background: #eee"</span>&gt;</span>我是一个没有设置浮动, </span><br><span class="line">也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成图2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>图1</p>
</blockquote>
<p><img src="https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png" alt="img"></p>
<blockquote>
<p>图2</p>
</blockquote>
<p><img src="https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w.png" alt="img"></p>
<h2 id="17-div水平垂直居中的方法"><a href="#17-div水平垂直居中的方法" class="headerlink" title="17.div水平垂直居中的方法"></a>17.div水平垂直居中的方法</h2><p>在平时，我们经常会碰到让一个div框针对某个模块上下左右都居中（水平垂直居中），其实针对这种情况，我们有多种方法实现。</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a><strong>方法一:</strong></h3><p>　　绝对定位方法：不确定当前div的宽度和高度，采用 transform: translate(-50%,-50%); 当前div的父级添加相对定位（position: relative;）</p>
<p>　　图片展示：</p>
<p>　　<img src="https://images2018.cnblogs.com/blog/1337908/201805/1337908-20180510132530310-507426098.png" alt="img"></p>
<p>　　代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    background:red;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left:50%;</span><br><span class="line">    top:50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a><strong>方法二:</strong></h3><p>　　绝对定位方法：确定了当前div的宽度，margin值为当前div宽度一半的负值</p>
<p>　　图片展示： 如方法一的图片展示</p>
<p>　　代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    width:600px;</span><br><span class="line">    height: 600px;</span><br><span class="line">    background:red;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left:50%;</span><br><span class="line">    top:50%;</span><br><span class="line">    margin-left:-300px;</span><br><span class="line">    margin-top:-300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a><strong>方法三：</strong></h3><p>　　绝对定位方法：绝对定位下top left right bottom 都设置0</p>
<p>　　图片展示： 如方法一的图片展示</p>
<p>　　代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">div.child&#123;</span><br><span class="line">    width: 600px;</span><br><span class="line">    height: 600px;</span><br><span class="line">    background: red;</span><br><span class="line">    position:absolute;</span><br><span class="line">    left:0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="方法四"><a href="#方法四" class="headerlink" title="方法四:"></a><strong>方法四:</strong></h3><p>　　flex布局方法：当前div的父级添加flex css样式</p>
<p>   展示图如下：</p>
<p>　　<img src="https://images2018.cnblogs.com/blog/1337908/201805/1337908-20180510131947523-2121210494.png" alt="img"></p>
<p>　　代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    height:800px;</span><br><span class="line">    -webkit-display:flex;</span><br><span class="line">    display:flex;</span><br><span class="line">    -webkit-align-items:center;</span><br><span class="line">    align-items:center;</span><br><span class="line">    -webkit-justify-content:center;</span><br><span class="line">    justify-content:center;</span><br><span class="line">    border:1px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line">div.child&#123;</span><br><span class="line">    width:600px;</span><br><span class="line">    height:600px;</span><br><span class="line">    background-color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="方法五"><a href="#方法五" class="headerlink" title="方法五:"></a><strong>方法五:</strong></h3><p>　　table-cell实现水平垂直居中: table-cell middle center组合使用</p>
<p>   展示图如下：</p>
<p>  <img src="https://images2018.cnblogs.com/blog/1337908/201805/1337908-20180510131450441-915853082.png" alt="img"></p>
<p>   代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.table-cell &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">    text-align: center;</span><br><span class="line">    width: 240px;</span><br><span class="line">    height: 180px;</span><br><span class="line">    border:1px solid #666;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="方法六"><a href="#方法六" class="headerlink" title="方法六:"></a><strong>方法六:</strong></h3><p>　　绝对定位：calc() 函数动态计算实现水平垂直居中</p>
<p>　　展示图如下：</p>
<p><img src="https://images2018.cnblogs.com/blog/1337908/201805/1337908-20180510131414396-1900857513.png" alt="img"></p>
<p>　　代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.calc&#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  border: 1px solid #ccc;</span><br><span class="line">  width: 400px;</span><br><span class="line">  height: 160px;</span><br><span class="line">&#125;</span><br><span class="line">.calc .child&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  left:-webkit-calc((400px - 200px)&#x2F;2);</span><br><span class="line">  top:-webkit-calc((160px - 50px)&#x2F;2);</span><br><span class="line">  left:-moz-calc((400px - 200px)&#x2F;2);</span><br><span class="line">  top:-moz-calc((160px - 50px)&#x2F;2);</span><br><span class="line">  left:calc((400px - 200px)&#x2F;2);</span><br><span class="line">  top:calc((160px - 50px)&#x2F;2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-display-、visibility、opacity的区别"><a href="#18-display-、visibility、opacity的区别" class="headerlink" title="18.display 、visibility、opacity的区别"></a>18.display 、visibility、opacity的区别</h2><h3 id="display-none"><a href="#display-none" class="headerlink" title="display: none;"></a>display: none;</h3><ol>
<li>DOM 结构：浏览器不会渲染 display 属性为 none 的元素，不占据空间；</li>
<li>事件监听：无法进行 DOM 事件监听；</li>
<li>性能：动态改变此属性时会引起重排，性能较差；</li>
<li>继承：不会被子元素继承，毕竟子类也不会被渲染；</li>
<li>transition：transition 不支持 display。</li>
</ol>
<h3 id="visibility-hidden"><a href="#visibility-hidden" class="headerlink" title="visibility: hidden;"></a>visibility: hidden;</h3><ol>
<li>DOM 结构：元素被隐藏，但是会被渲染不会消失，占据空间；</li>
<li>事件监听：无法进行 DOM 事件监听；</li>
<li>性 能：动态改变此属性时会引起重绘，性能较高；</li>
<li>继 承：会被子元素继承，子元素可以通过设置 visibility: visible; 来取消隐藏；</li>
<li>transition：visibility 会立即显示，隐藏时会延时</li>
</ol>
<h3 id="opacity-0"><a href="#opacity-0" class="headerlink" title="opacity: 0;"></a>opacity: 0;</h3><ol>
<li>DOM 结构：透明度为 100%，元素隐藏，占据空间；</li>
<li>事件监听：可以进行 DOM 事件监听；</li>
<li>性 能：提升为合成层，不会触发重绘，性能较高；</li>
<li>继 承：会被子元素继承,且，子元素并不能通过 opacity: 1 来取消隐藏；</li>
<li>transition：opacity 可以延时显示和隐藏</li>
</ol>
<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="1-js的原型和原型链"><a href="#1-js的原型和原型链" class="headerlink" title="1.js的原型和原型链"></a>1.js的原型和原型链</h2><h3 id="1-原型和原型链"><a href="#1-原型和原型链" class="headerlink" title="1.原型和原型链"></a>1.原型和原型链</h3><blockquote>
<p><a href="https://blog.csdn.net/weixin_42614080/article/details/93413476" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h3 id="2-prototype"><a href="#2-prototype" class="headerlink" title="2.prototype"></a>2.prototype</h3><blockquote>
<p><a href="https://www.cnblogs.com/wulihong/p/8906231.html" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h2 id="2-Javascript作用链域"><a href="#2-Javascript作用链域" class="headerlink" title="2.Javascript作用链域?"></a>2.Javascript作用链域?</h2><blockquote>
<p>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局函数，这种组织形式就是作用域链。</p>
</blockquote>
<h2 id="3-谈谈This对象的理解"><a href="#3-谈谈This对象的理解" class="headerlink" title="3.谈谈This对象的理解"></a>3.谈谈This对象的理解</h2><blockquote>
<p>this总是指向函数的直接调用者（而非间接调用者）； 如果有new关键字，this指向new出来的那个对象； 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；</p>
</blockquote>
<h2 id="4-eval是做什么的？"><a href="#4-eval是做什么的？" class="headerlink" title="4.eval是做什么的？"></a>4.eval是做什么的？</h2><blockquote>
<p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码.</p>
<p>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</p>
<p>由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’);</p>
</blockquote>
<h2 id="5-什么是闭包（closure），为什么要用它？"><a href="#5-什么是闭包（closure），为什么要用它？" class="headerlink" title="5.什么是闭包（closure），为什么要用它？"></a>5.什么是闭包（closure），为什么要用它？</h2><blockquote>
<p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。</p>
<p><a href="https://blog.csdn.net/weixin_43586120/article/details/89456183" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h2 id="6-javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？"><a href="#6-javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="6.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？"></a>6.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</h2><blockquote>
<p>使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用； 保证代码运行的安全,限制函数中的arguments修改; 提高编译器效率，增加运行速度；</p>
</blockquote>
<h2 id="7-如何判断一个对象是否属于某个类型？"><a href="#7-如何判断一个对象是否属于某个类型？" class="headerlink" title="7.如何判断一个对象是否属于某个类型？"></a>7.如何判断一个对象是否属于某个类型？</h2><blockquote>
<p>// 判断对象类型最好的方式<br>// 对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。<br>Object.prototype.toString.call(‘’) ;   // [object String]<br>Object.prototype.toString.call(1) ;    // [object Number]<br>Object.prototype.toString.call(true) ; // [object Boolean]<br>Object.prototype.toString.call(Symbol()); //[object Symbol]<br>Object.prototype.toString.call(undefined) ; // [object Undefined]<br>Object.prototype.toString.call(null) ; // [object Null]<br>Object.prototype.toString.call(new Function()) ; // [object Function]<br>Object.prototype.toString.call(new Date()) ; // [object Date]<br>Object.prototype.toString.call([]) ; // [object Array]<br>Object.prototype.toString.call(new RegExp()) ; // [object RegExp]<br>Object.prototype.toString.call(new Error()) ; // [object Error]<br>Object.prototype.toString.call(document) ; // [object HTMLDocument]<br>Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用</p>
</blockquote>
<h2 id="8-new一个对象的过程"><a href="#8-new一个对象的过程" class="headerlink" title="8.new一个对象的过程"></a>8.new一个对象的过程</h2><blockquote>
<p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。<br>2、属性和方法被加入到 this 引用的对象中。<br>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p>
</blockquote>
<h2 id="9-模块化开发怎么做"><a href="#9-模块化开发怎么做" class="headerlink" title="9.模块化开发怎么做"></a>9.模块化开发怎么做</h2><blockquote>
<p>立即执行函数,不暴露私有成员</p>
</blockquote>
<h2 id="10-AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？"><a href="#10-AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？" class="headerlink" title="10. AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？"></a>10. AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</h2><blockquote>
<p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。 2. CMD 推崇依赖就近，AMD 推崇依赖前置。</p>
</blockquote>
<h2 id="11-requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><a href="#11-requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）" class="headerlink" title="11.requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）"></a>11.requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h2><blockquote>
<p>requireJS是基于AMD模块加载规范，使用回调函数来解决模块加载的问题.</p>
<p><strong>（如何动态加载的？）</strong></p>
<p>requireJS是使用创建script元素，通过指定script元素的src属性来实现加载模块的。</p>
<p>如何避免多次加载的</p>
<p>模块的定义是一个<code>function</code>，这个<code>function</code>实际是一个 factory（工厂模式），这个 factory 在需要使用的时候（require(“xxxx”) 的时候）才有可能会被调用。因为如果检查到已经调用过，已经生成了模块实例，就直接返回模块实例，而不再次调用工厂方法了</p>
<p>如何处理缓存问题？ </p>
<p>加上一个版本号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">    urlArgs:&quot;v&#x3D;1.23&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="12-列举几条-JavaScript-的基本代码规范"><a href="#12-列举几条-JavaScript-的基本代码规范" class="headerlink" title="12.列举几条 JavaScript 的基本代码规范"></a>12.列举几条 JavaScript 的基本代码规范</h2><blockquote>
<p>（1）不要在同一行声明多个变量 </p>
<p>（2）如果你不知道数组的长度，使用 push </p>
<p>（3）请使用 ===/!== 来比较 true/false 或者数值 </p>
<p>（4）对字符串使用单引号 ‘’(因为大多时候我们的字符串。特别html会出现”) </p>
<p>（5）使用对象字面量替代 new Array 这种形式 </p>
<p>（6）绝对不要在一个非函数块里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同 </p>
<p>（7）不要使用全局函数 </p>
<p>（8）总是使用 var 来声明变量，如果不这么做将导致产生全局变量，我们要避免污染全局命名空间 </p>
<p>（9）Switch 语句必须带有 default 分支 </p>
<p>（10）使用 /<em>*…</em>/ 进行多行注释，包括描述，指定类型以及参数值和返回值 </p>
<p>（11）函数不应该有时候有返回值，有时候没有返回值 </p>
<p>（12）语句结束一定要加分号 </p>
<p>（13）for 循环必须使用大括号</p>
<p> （14）if 语句必须使用大括号 </p>
<p>（15）for-in 循环中的变量应该使用 var 关键字明确限定作用域，从而避免作用域污染</p>
<p> （16）避免单个字符名，让你的变量名有描述意义</p>
<p> （17）当命名对象、函数和实例时使用驼峰命名规则 </p>
<p>（18）给对象原型分配方法，而不是用一个新的对象覆盖原型，覆盖原型会使继承出现问题</p>
</blockquote>
<h2 id="13-DOM操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#13-DOM操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="13.DOM操作——怎样添加、移除、移动、复制、创建和查找节点?"></a>13.DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</h2><blockquote>
<p>（1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 </p>
<p>（2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点 </p>
<p>（3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性</p>
</blockquote>
<h2 id="14-如何判断当前脚本运行在浏览器还是node环境中？（阿里）"><a href="#14-如何判断当前脚本运行在浏览器还是node环境中？（阿里）" class="headerlink" title="14.如何判断当前脚本运行在浏览器还是node环境中？（阿里）"></a>14.如何判断当前脚本运行在浏览器还是node环境中？（阿里）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this &#x3D;&#x3D;&#x3D; window ? &#39;browser&#39; : &#39;node&#39;;</span><br></pre></td></tr></table></figure>

<h2 id="15-实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应"><a href="#15-实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应" class="headerlink" title="15.实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应"></a>15.实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应</h2><blockquote>
<p><a href="http://www.haorooms.com/post/ajax_historybackprev" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h2 id="16-把-Script-标签-放在页面的最底部的body封闭之前-和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#16-把-Script-标签-放在页面的最底部的body封闭之前-和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="16.把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？"></a>16.把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？</h2><blockquote>
<p>如果说放在body的封闭之前，将会阻塞其他资源的加载。<br>如果放在body封闭之后，不会影响body内元素的加载。</p>
<p>现在浏览器script标签支持 async 和 defer 属性. 应用这些属性当script被下载时，浏览器更安全而且可以并行下载（下载script并不阻断HTML解析）。 1.async标记的Script异步执行下载，并执行。这意味着script下载时并不阻塞HTML的解析，并且下载结束script马上执行。 2.defer标签的script顺序执行。这种方式也不会阻断浏览器解析HTML。 跟 async不同, defer scripts在整个文档里的script都被下载完才顺序执行。</p>
</blockquote>
<h2 id="17-什么是Polyfill"><a href="#17-什么是Polyfill" class="headerlink" title="17.什么是Polyfill?"></a>17.什么是Polyfill?</h2><blockquote>
<p><code>Polyfill</code>是一个<code>js</code>库，主要抚平不同浏览器之间对js实现的差异。比如，<code>html5</code>的<code>storage</code>(<code>session</code>,<code>local</code>), 不同浏览器，不同版本，有些支持，有些不支持。<code>Polyfill</code>（<code>Polyfill</code>有很多，在<code>GitHub</code>上<a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills），帮你把这些差异化抹平，不支持的变得支持了（典型做法是在IE浏览器中增加" target="_blank" rel="noopener">https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills），帮你把这些差异化抹平，不支持的变得支持了（典型做法是在IE浏览器中增加</a> window.XMLHttpRequest ，内部实现使用 ActiveXObject。）</p>
</blockquote>
<h2 id="18-做的项目中，有没有用过或自己实现一些-polyfill-方案（兼容性处理方案）？"><a href="#18-做的项目中，有没有用过或自己实现一些-polyfill-方案（兼容性处理方案）？" class="headerlink" title="18.做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？"></a>18.做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？</h2><blockquote>
<p>html5shiv、Geolocation、Placeholder</p>
</blockquote>
<h2 id="19-我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？"><a href="#19-我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？" class="headerlink" title="19.我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？"></a>19.我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？</h2><blockquote>
<p>按照W3C的标准，先发生捕获事件，后发生冒泡事件。所有事件的顺序是：其他元素捕获阶段事件 -&gt; 本元素代码顺序事件 -&gt; 其他元素冒泡阶段事件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// div-capture &gt; btn-bubble &gt; btn-capture &gt; div-bubble</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bubble'</span>,<span class="string">'btn'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'capture'</span>,<span class="string">'btn'</span>);</span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bubble'</span>,<span class="string">'div'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">div.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'capture'</span>,<span class="string">'div'</span>);</span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="20-节流和防抖"><a href="#20-节流和防抖" class="headerlink" title="20.节流和防抖"></a>20.节流和防抖</h2><blockquote>
<h3 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h3><p><strong>概念：</strong> <code>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</code></p>
<h3 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h3><p><strong>概念：</strong> <code>规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</code></p>
</blockquote>
<h2 id="21-对Node的优点和缺点提出了自己的看法"><a href="#21-对Node的优点和缺点提出了自己的看法" class="headerlink" title="21.对Node的优点和缺点提出了自己的看法"></a>21.对Node的优点和缺点提出了自己的看法</h2><blockquote>
<p>（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求， 因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。 此外，与Node代理服务器交互的客户端代码是由javascript语言编写的， 因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情</p>
<p>（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变， 而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子</p>
</blockquote>
<h2 id="22-js实现继承"><a href="#22-js实现继承" class="headerlink" title="22.js实现继承"></a>22.js实现继承</h2><blockquote>
<p>所有的JS对象都有一个prototype属性，指向它的原型对象。当试图访问一个对象的属性时，如果没有在该对象上找到，它还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>
</blockquote>
<h2 id="23-闭包使用的优缺点"><a href="#23-闭包使用的优缺点" class="headerlink" title="23. 闭包使用的优缺点"></a>23. 闭包使用的优缺点</h2><blockquote>
<p>优点：1.保护函数内部变量的安全，加强了封装性 2.在内存中维持一个变量 3.设计私有方法和变量 4.可以读取函数内部的变量</p>
<p> 缺点：1.导致内存泄漏，使用不当会造成额外的内存占用 2.可以改变父函数的变量，所以使用时要谨慎</p>
</blockquote>
<h2 id="24-JS数据类型"><a href="#24-JS数据类型" class="headerlink" title="24.JS数据类型"></a>24.JS数据类型</h2><blockquote>
<p>JavaScript语言规定了7种语言类型，他们分别是：<br>Number（数字）<br>Boolean（布尔值）<br>String（字符串）<br>Null （空）<br>Undefined （未定义）<br>Symbol （es6新增，表示独一无二的值）<br>Object（对象）<br>其中，除了Object是对象类型，其他的都是原始（基本）类型。<br>并且基本数据类型的值不可改变，对象数据类型的值可以改变</p>
</blockquote>
<h2 id="25-async和defer"><a href="#25-async和defer" class="headerlink" title="25.async和defer"></a>25.async和defer</h2><blockquote>
<script src="script.js"></script>
<p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p>
<script async src="script.js"></script>
<p>有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。</p>
<script defer src="myscript.js"></script>
<p>有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。</p>
<p>//然后从实用角度来说呢，首先把所有脚本都丢到 </body> 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。    </p>
</blockquote>
<h2 id="26-介绍模块化发展历程"><a href="#26-介绍模块化发展历程" class="headerlink" title="26.介绍模块化发展历程"></a>26.介绍模块化发展历程</h2><p>模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p>
<p><strong>IIFE</strong>： 使用自执行函数来编写模块化，特点：<strong>在一个单独的函数作用域中执行代码，避免变量冲突</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">	data:[]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p><strong>AMD</strong>： 使用requireJS 来编写模块化，特点：<strong>依赖必须提前声明好</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'./index.js'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// code 就是index.js 返回的内容</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>CMD</strong>： 使用seaJS 来编写模块化，特点：<strong>支持动态引入依赖文件</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">'./index.js'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>CommonJS</strong>： nodejs 中自带的模块化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>UMD</strong>：兼容AMD，CommonJS 模块化语法。</p>
<p><strong>webpack(require.ensure)</strong>：webpack 2.x 版本中的代码分割。</p>
<p><strong>ES Modules</strong>： ES6 引入的模块化，支持import 来引入另一个 js 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><h4 id="模块化的作用"><a href="#模块化的作用" class="headerlink" title="模块化的作用"></a>模块化的作用</h4><p>模块化是为了处理全局污染和依赖管理混乱的问题</p>
<h4 id="模块化-1"><a href="#模块化-1" class="headerlink" title="模块化"></a>模块化</h4><p>因为一开始js本身没有提供模块化的机制，所以才会衍生出commonJS、AMD、CMD和UMD这么多模块化规范。js在ES6时原生提供了import和export模块化机制</p>
<h5 id="commonJS"><a href="#commonJS" class="headerlink" title="commonJS"></a>commonJS</h5><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>文件即模块，每个文件通过module来表示，用require来引用其他依赖，用module.exports来导出自身</p>
<h6 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h6><p>通过require去引用文件时，会将文件执行一遍后，将其执行结果通过浅克隆的方式，写入全局内存。后续再require该路径，就直接从内存里取出，不需要重新执行对应的文件</p>
<h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><p>commonJS是服务器编程范式，因为服务器上所有文件都在硬盘里，通过同步加载的方式即可，所以该规范是同步加载规范。同时它是在运行时加载，也就是你可以在require里拼接变量，在加载时会自动识别出最终的实际路径</p>
<h5 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h5><h6 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h6><p>define(module, [dep1, dep2], callback)</p>
<h6 id="机制-1"><a href="#机制-1" class="headerlink" title="机制"></a>机制</h6><p>通过require加载时，它会先加载对应的依赖，等依赖资源加载完之后，会执行回调函数，将依赖作为入参，执行对应的业务逻辑</p>
<h6 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h6><p>AMD机制是浏览器编程范式，它是在客户端使用的，由于资源都是在服务器上，所以它是异步加载。同时，它最大的特点是强调依赖前置。</p>
<h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><h6 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h6><p>机制和AMD类似，最大的区别就是CMD强调延迟加载，对应的依赖等到回调函数里执行具体依赖语句，才会去加载，但是AMD在后续版本里也支持了延迟加载的写法</p>
<h6 id="机制-2"><a href="#机制-2" class="headerlink" title="机制"></a>机制</h6><p>同上</p>
<h6 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h6><p>同上</p>
<h5 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h5><h6 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h6><p>CommonJS、AMD、CMD并行的状态下，就需要一种方案能够兼容他们，这样我们在开发时， 就不需要再去考虑依赖模块所遵循的规范了，而UMD的出现就是为了解决这个问题。</p>
<h5 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h5><h6 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h6><p>通过import引入依赖，通过export导出依赖</p>
<h6 id="机制-3"><a href="#机制-3" class="headerlink" title="机制"></a>机制</h6><p>ES6的模块机制在依赖模块时并不会先去预加载整个脚本，而是生成一个只读引用，并且静态解析依赖，等到执行代码时，再去依赖里取出实际需要的模块</p>
<h6 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h6><p>编译时加载，不允许在里边引用变量，必须为真实的文件路径。可以通过调用import()语句，会生成一个promise去加载对应的文件，这样子就是运行时加载，可以在路径里边编写变量</p>
<h2 id="27-箭头函数和普通函数的区别"><a href="#27-箭头函数和普通函数的区别" class="headerlink" title="27.箭头函数和普通函数的区别"></a>27.箭头函数和普通函数的区别</h2><blockquote>
<p>箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：</p>
<p>1、函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>2、不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>3、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</p>
<p>4、不可以使用 new 命令，因为：</p>
<ul>
<li>没有自己的 this，无法调用 call，apply。</li>
<li>没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 <strong>proto</strong></li>
</ul>
</blockquote>
<h2 id="28-JS执行顺序机制"><a href="#28-JS执行顺序机制" class="headerlink" title="28.JS执行顺序机制"></a>28.JS执行顺序机制</h2><p>本文的目的就是要保证你彻底弄懂javascript的执行机制，如果读完本文还不懂，可以揍我。</p>
<p>不论你是javascript新手还是老鸟，不论是面试求职，还是日常开发工作，我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。因为javascript是一门单线程语言，所以我们可以得出结论：</p>
<ul>
<li>javascript是按照语句出现的顺序执行的</li>
</ul>
<p>看到这里读者要打人了：我难道不知道js是一行一行执行的？还用你说？稍安勿躁，正因为js是一行一行执行的，所以我们以为js都是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; &#39;1&#39;;</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">let b &#x3D; &#39;2&#39;;</span><br><span class="line">console.log(b);复制代码</span><br></pre></td></tr></table></figure>



<p><img src="https://user-gold-cdn.xitu.io/2017/11/20/15fd87f7221d0dbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>然而实际上js是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&#39;定时器开始啦&#39;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(&#39;马上执行for循环啦&#39;);</span><br><span class="line">    for(var i &#x3D; 0; i &lt; 10000; i++)&#123;</span><br><span class="line">        i &#x3D;&#x3D; 99 &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(&#39;执行then函数啦&#39;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#39;代码执行结束&#39;);复制代码</span><br></pre></td></tr></table></figure>



<p><img src="https://user-gold-cdn.xitu.io/2017/11/20/15fd87d38acc4905?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>依照<strong>js是按照语句出现的顺序执行</strong>这个理念，我自信的写下输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&quot;定时器开始啦&quot;</span><br><span class="line">&#x2F;&#x2F;&quot;马上执行for循环啦&quot;</span><br><span class="line">&#x2F;&#x2F;&quot;执行then函数啦&quot;</span><br><span class="line">&#x2F;&#x2F;&quot;代码执行结束&quot;复制代码</span><br></pre></td></tr></table></figure>

<p>去chrome上验证下，结果完全不对，瞬间懵了，说好的一行一行执行的呢？</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/20/15fd8840f3c3f109?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>我们真的要彻底弄明白javascript的执行机制了。</p>
<h3 id="1-关于javascript"><a href="#1-关于javascript" class="headerlink" title="1.关于javascript"></a>1.关于javascript</h3><p>javascript是一门<strong>单线程</strong>语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！</p>
<h3 id="2-javascript事件循环"><a href="#2-javascript事件循环" class="headerlink" title="2.javascript事件循环"></a>2.javascript事件循环</h3><p>既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p>
<ul>
<li>同步任务</li>
<li>异步任务</li>
</ul>
<p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdd88994142347?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>导图要表达的内容用文字来表述的话：</p>
<ul>
<li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li>
<li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li>
<li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li>
<li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li>
</ul>
<p>我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p>
<p>说了这么多文字，不如直接一段代码更直白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let data &#x3D; [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;发送成功!&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;代码执行结束&#39;);复制代码</span><br></pre></td></tr></table></figure>

<p>上面是一段简易的<code>ajax</code>请求代码：</p>
<ul>
<li>ajax进入Event Table，注册回调函数<code>success</code>。</li>
<li>执行<code>console.log(&#39;代码执行结束&#39;)</code>。</li>
<li>ajax事件完成，回调函数<code>success</code>进入Event Queue。</li>
<li>主线程从Event Queue读取回调函数<code>success</code>并执行。</li>
</ul>
<p>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。</p>
<h3 id="3-又爱又恨的setTimeout"><a href="#3-又爱又恨的setTimeout" class="headerlink" title="3.又爱又恨的setTimeout"></a>3.又爱又恨的setTimeout</h3><p>大名鼎鼎的<code>setTimeout</code>无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;延时3秒&#39;);</span><br><span class="line">&#125;,3000)复制代码</span><br></pre></td></tr></table></figure>

<p>渐渐的<code>setTimeout</code>用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？</p>
<p>先看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;,3000)</span><br><span class="line">console.log(&#39;执行console&#39;);复制代码</span><br></pre></td></tr></table></figure>

<p>根据前面我们的结论，<code>setTimeout</code>是异步的，应该先执行<code>console.log</code>这个同步任务，所以我们的结论是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;执行console</span><br><span class="line">&#x2F;&#x2F;task()复制代码</span><br></pre></td></tr></table></figure>

<p>去验证一下，结果正确！<br>然后我们修改一下前面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    task()</span><br><span class="line">&#125;,3000)</span><br><span class="line"></span><br><span class="line">sleep(10000000)复制代码</span><br></pre></td></tr></table></figure>

<p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行<code>task()</code>需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？</p>
<p>这时候我们需要重新理解<code>setTimeout</code>的定义。我们先说上述代码是怎么执行的：</p>
<ul>
<li><code>task()</code>进入Event Table并注册,计时开始。</li>
<li>执行<code>sleep</code>函数，很慢，非常慢，计时仍在继续。</li>
<li>3秒到了，计时事件<code>timeout</code>完成，<code>task()</code>进入Event Queue，但是<code>sleep</code>也太慢了吧，还没执行完，只好等着。</li>
<li><code>sleep</code>终于执行完了，<code>task()</code>终于从Event Queue进入了主线程执行。</li>
</ul>
<p>上述的流程走完，我们知道<code>setTimeout</code>这个函数，是经过指定时间后，把要执行的任务(本例中为<code>task()</code>)加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p>
<p>我们还经常遇到<code>setTimeout(fn,0)</code>这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？</p>
<p>答案是不会的，<code>setTimeout(fn,0)</code>的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;代码1</span><br><span class="line">console.log(&#39;先执行这里&#39;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;执行啦&#39;)</span><br><span class="line">&#125;,0);复制代码</span><br><span class="line">&#x2F;&#x2F;代码2</span><br><span class="line">console.log(&#39;先执行这里&#39;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;执行啦&#39;)</span><br><span class="line">&#125;,3000);复制代码</span><br></pre></td></tr></table></figure>

<p>代码1的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先执行这里</span><br><span class="line">&#x2F;&#x2F;执行啦复制代码</span><br></pre></td></tr></table></figure>

<p>代码2的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先执行这里</span><br><span class="line">&#x2F;&#x2F; ... 3s later</span><br><span class="line">&#x2F;&#x2F; 执行啦复制代码</span><br></pre></td></tr></table></figure>

<p>关于<code>setTimeout</code>要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。</p>
<h3 id="4-又恨又爱的setInterval"><a href="#4-又恨又爱的setInterval" class="headerlink" title="4.又恨又爱的setInterval"></a>4.又恨又爱的setInterval</h3><p>上面说完了<code>setTimeout</code>，当然不能错过它的孪生兄弟<code>setInterval</code>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<code>setInterval</code>会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p>
<p>唯一需要注意的一点是，对于<code>setInterval(fn,ms)</code>来说，我们已经知道不是每过<code>ms</code>秒会执行一次<code>fn</code>，而是每过<code>ms</code>秒，会有<code>fn</code>进入Event Queue。一旦<strong><code>setInterval</code>的回调函数<code>fn</code>执行时间超过了延迟时间<code>ms</code>，那么就完全看不出来有时间间隔了</strong>。这句话请读者仔细品味。</p>
<h3 id="5-Promise与process-nextTick-callback"><a href="#5-Promise与process-nextTick-callback" class="headerlink" title="5.Promise与process.nextTick(callback)"></a>5.Promise与process.nextTick(callback)</h3><p>传统的定时器我们已经研究过了，接着我们探究<code>Promise</code>与<code>process.nextTick(callback)</code>的表现。</p>
<p><code>Promise</code>的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Promise</a>。而<code>process.nextTick(callback)</code>类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。</p>
<p>我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p>
<ul>
<li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li>
<li>micro-task(微任务)：Promise，process.nextTick</li>
</ul>
<p>不同类型的任务会进入对应的Event Queue，比如<code>setTimeout</code>和<code>setInterval</code>会进入相同的Event Queue。</p>
<p>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#39;setTimeout&#39;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&#39;promise&#39;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#39;then&#39;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&#39;console&#39;);复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>这段代码作为宏任务，进入主线程。</li>
<li>先遇到<code>setTimeout</code>，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</li>
<li>接下来遇到了<code>Promise</code>，<code>new Promise</code>立即执行，<code>then</code>函数分发到微任务Event Queue。</li>
<li>遇到<code>console.log()</code>，立即执行。</li>
<li>好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了<code>then</code>在微任务Event Queue里面，执行。</li>
<li>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中<code>setTimeout</code>对应的回调函数，立即执行。</li>
<li>结束。</li>
</ul>
<p>事件循环，宏任务，微任务的关系如图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdcea13361a1ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;1&#39;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#39;2&#39;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#39;3&#39;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#39;4&#39;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#39;5&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">    console.log(&#39;6&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&#39;7&#39;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#39;8&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#39;9&#39;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#39;10&#39;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#39;11&#39;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#39;12&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)复制代码</span><br></pre></td></tr></table></figure>

<p>第一轮事件循环流程分析如下：</p>
<ul>
<li>整体script作为第一个宏任务进入主线程，遇到<code>console.log</code>，输出1。</li>
<li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。我们暂且记为<code>setTimeout1</code>。</li>
<li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。我们记为<code>process1</code>。</li>
<li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。我们记为<code>then1</code>。</li>
<li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，我们记为<code>setTimeout2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">宏任务Event Queue</th>
<th align="center">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td align="center">setTimeout1</td>
<td align="center">process1</td>
</tr>
<tr>
<td align="center">setTimeout2</td>
<td align="center">then1</td>
</tr>
</tbody></table>
<ul>
<li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</li>
<li>我们发现了<code>process1</code>和<code>then1</code>两个微任务。</li>
<li>执行<code>process1</code>,输出6。</li>
<li>执行<code>then1</code>，输出8。</li>
</ul>
<p>好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从<code>setTimeout1</code>宏任务开始：</p>
<ul>
<li>首先输出2。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为<code>process2</code>。<code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为<code>then2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">宏任务Event Queue</th>
<th align="center">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td align="center">setTimeout2</td>
<td align="center">process2</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">then2</td>
</tr>
</tbody></table>
<ul>
<li>第二轮事件循环宏任务结束，我们发现有<code>process2</code>和<code>then2</code>两个微任务可以执行。</li>
<li>输出3。</li>
<li>输出5。</li>
<li>第二轮事件循环结束，第二轮输出2，4，3，5。</li>
<li>第三轮事件循环开始，此时只剩setTimeout2了，执行。</li>
<li>直接输出9。</li>
<li>将<code>process.nextTick()</code>分发到微任务Event Queue中。记为<code>process3</code>。</li>
<li>直接执行<code>new Promise</code>，输出11。</li>
<li>将<code>then</code>分发到微任务Event Queue中，记为<code>then3</code>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">宏任务Event Queue</th>
<th align="center">微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">process3</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">then3</td>
</tr>
</tbody></table>
<ul>
<li>第三轮事件循环宏任务执行结束，执行两个微任务<code>process3</code>和<code>then3</code>。</li>
<li>输出10。</li>
<li>输出12。</li>
<li>第三轮事件循环结束，第三轮输出9，11，10，12。</li>
</ul>
<p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。<br>(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p>
<h3 id="6-写在最后"><a href="#6-写在最后" class="headerlink" title="6.写在最后"></a>6.写在最后</h3><h4 id="1-js的异步"><a href="#1-js的异步" class="headerlink" title="(1)js的异步"></a>(1)js的异步</h4><p>我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。</p>
<h4 id="2-事件循环Event-Loop"><a href="#2-事件循环Event-Loop" class="headerlink" title="(2)事件循环Event Loop"></a>(2)事件循环Event Loop</h4><p>事件循环是js实现异步的一种方法，也是js的执行机制。</p>
<h4 id="3-javascript的执行和运行"><a href="#3-javascript的执行和运行" class="headerlink" title="(3)javascript的执行和运行"></a>(3)javascript的执行和运行</h4><p>执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。</p>
<h4 id="4-setImmediate"><a href="#4-setImmediate" class="headerlink" title="(4)setImmediate"></a>(4)setImmediate</h4><p>微任务和宏任务还有很多种类，比如<code>setImmediate</code>等等，执行都是有共同点的，有兴趣的同学可以自行了解。</p>
<h4 id="5-最后的最后"><a href="#5-最后的最后" class="headerlink" title="(5)最后的最后"></a>(5)最后的最后</h4><ul>
<li>javascript是一门单线程语言</li>
<li>Event Loop是javascript的执行机制</li>
</ul>
<p>牢牢把握两个基本点，以认真学习javascript为中心，早日实现成为前端高手的伟大梦想！</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdd96beade6575?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="29-异步解决方案"><a href="#29-异步解决方案" class="headerlink" title="29.异步解决方案"></a>29.异步解决方案</h2><h4 id="1-回调函数（callback）"><a href="#1-回调函数（callback）" class="headerlink" title="1. 回调函数（callback）"></a>1. 回调函数（callback）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// callback 函数体</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p><strong>缺点：回调地狱，不能用 try catch 捕获错误，不能 return</strong></p>
<p>回调地狱的根本问题在于：</p>
<ul>
<li>缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</li>
<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（<strong>控制反转</strong>）</li>
<li>嵌套函数过多的多话，很难处理错误</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'XXX1'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// callback 函数体</span></span><br><span class="line">    ajax(<span class="string">'XXX2'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// callback 函数体</span></span><br><span class="line">        ajax(<span class="string">'XXX3'</span>, () =&gt; &#123;</span><br><span class="line">            <span class="comment">// callback 函数体</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>优点：解决了同步的问题</strong>（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）</p>
<h4 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2. Promise"></a>2. Promise</h4><p>Promise就是为了解决callback的问题而产生的。</p>
<p>Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装</p>
<p><strong>优点：解决了回调地狱的问题</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'XXX1'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 操作逻辑</span></span><br><span class="line">      <span class="keyword">return</span> ajax(<span class="string">'XXX2'</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 操作逻辑</span></span><br><span class="line">      <span class="keyword">return</span> ajax(<span class="string">'XXX3'</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 操作逻辑</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>缺点：无法取消 Promise ，错误需要通过回调函数来捕获</strong></p>
<h4 id="3-Generator"><a href="#3-Generator" class="headerlink" title="3. Generator"></a>3. Generator</h4><p><strong>特点：可以控制函数的执行</strong>，可以配合 co 函数库使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> ajax(<span class="string">'XXX1'</span>, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(<span class="string">'XXX2'</span>, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(<span class="string">'XXX3'</span>, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch()</span><br><span class="line"><span class="keyword">let</span> result1 = it.next()</span><br><span class="line"><span class="keyword">let</span> result2 = it.next()</span><br><span class="line"><span class="keyword">let</span> result3 = it.next()</span><br></pre></td></tr></table></figure>

<h4 id="4-Async-await"><a href="#4-Async-await" class="headerlink" title="4. Async/await"></a>4. Async/await</h4><p>async、await 是异步的终极解决方案</p>
<p><strong>优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题</strong></p>
<p><strong>缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式</span></span><br><span class="line">  <span class="comment">// 如果有依赖性的话，其实就是解决回调地狱的例子了</span></span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">'XXX1'</span>)</span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">'XXX2'</span>)</span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">'XXX3'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看一个使用 <code>await</code> 的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, a) <span class="comment">// -&gt; '2' 10</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, a) <span class="comment">// -&gt; '1' 1</span></span><br></pre></td></tr></table></figure>

<p>对于以上代码你可能会有疑惑，让我来解释下原因</p>
<ul>
<li>首先函数 <code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为 <code>await</code> 内部实现了 <code>generator</code> ，<strong><code>generator</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</strong></li>
<li>因为 <code>await</code> 是异步操作，后来的表达式不返回 <code>Promise</code> 的话，就会包装成 <code>Promise.reslove(返回值)</code>，然后会去执行函数外的同步代码</li>
<li>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 0 + 10</code></li>
</ul>
<p>上述解释中提到了 <code>await</code> 内部实现了 <code>generator</code>，其实 <code>await</code> 就是 <code>generator</code> 加上 <code>Promise</code>的语法糖，且内部实现了自动执行 <code>generator</code>。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。</p>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="1-vue的生命周期"><a href="#1-vue的生命周期" class="headerlink" title="1.vue的生命周期"></a>1.vue的生命周期</h2><blockquote>
<p>vue的生命周期:<br>vue每个组件都是独立的，每个组件都有一个属于它的生命周期，从一个组件创建、数据初始化、挂载、更新、销毁，这就是一个组件所谓的生命周期</p>
<p>beforeCreate</p>
<p>created</p>
<p>beforeMount</p>
<p>mounted</p>
<p>(</p>
<p>​     beforeUpdate</p>
<p>​     updated</p>
<p>)</p>
<p>beforeDestroy</p>
<p>destroyed</p>
<p>这篇文章说得挺好的，想详细的可以去看一下<a href="https://www.jianshu.com/p/410b6099be69" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<img src = "https://upload-images.jianshu.io/upload_images/13119812-eaf493b1b2050a93.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp">

<h2 id="2-Webpack热更新实现原理"><a href="#2-Webpack热更新实现原理" class="headerlink" title="2.Webpack热更新实现原理?"></a>2.Webpack热更新实现原理?</h2><blockquote>
<ol>
<li>页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回前端</li>
<li>客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash</li>
<li>修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端</li>
<li>客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档</li>
<li>hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新</li>
</ol>
</blockquote>
<h1 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h1><h2 id="1-网页验证码是干嘛的，是为了解决什么安全问题？"><a href="#1-网页验证码是干嘛的，是为了解决什么安全问题？" class="headerlink" title="1.网页验证码是干嘛的，是为了解决什么安全问题？"></a>1.网页验证码是干嘛的，是为了解决什么安全问题？</h2><blockquote>
<p>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水； 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</p>
</blockquote>
<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h2 id="1-Ajax-解决浏览器缓存问题"><a href="#1-Ajax-解决浏览器缓存问题" class="headerlink" title="1. Ajax 解决浏览器缓存问题"></a>1. Ajax 解决浏览器缓存问题</h2><blockquote>
<p>1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)</p>
<p>2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。</p>
<p>3、在URL后面加上一个随机数： “fresh=” + Math.random();。 </p>
<p>4、在URL后面加上时间戳：”nowtime=” + new Date().getTime();。 </p>
<p>5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。</p>
</blockquote>
<h2 id="2-JQ实现原理"><a href="#2-JQ实现原理" class="headerlink" title="2.JQ实现原理"></a>2.JQ实现原理</h2><blockquote>
<p>jQuery采用的是构造函数模式进行开发的,jQuery是一个类</p>
<p><a href="http://www.zhangxinxu.com/wordpress/2013/07/jquery-原理-机制/" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h2 id="3-深复制和浅复制的区别"><a href="#3-深复制和浅复制的区别" class="headerlink" title="3.深复制和浅复制的区别"></a>3.深复制和浅复制的区别</h2><blockquote>
<p><a href="https://www.cnblogs.com/yuqingfamily/p/5813650.html" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h2 id="4-jquery-extend-与-jquery-fn-extend的区别？"><a href="#4-jquery-extend-与-jquery-fn-extend的区别？" class="headerlink" title="4.jquery.extend 与 jquery.fn.extend的区别？"></a>4.jquery.extend 与 jquery.fn.extend的区别？</h2><blockquote>
<p>jquery.extend 为jquery类添加类方法，可以理解为添加静态方法</p>
<p>jquery.fn.extend: 源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数 使用： jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。</p>
<p><strong>两者区别总结：</strong></p>
<p>1、两者调用方式不同：</p>
<p>​    jQuery.extend(),一般由传入的全局函数来调用，主要是用来拓展个全局函数，如$.init()，$.ajax();</p>
<p>​    jQuery.fn.extend(),一般由具体的实例对象来调用，可以用来拓展个选择器，例如$.fn.each();</p>
<p>2、两者的主要功能作用不同：</p>
<p>​    jQuery.extend(object); 为扩展jQuery类本身，为自身添加新的方法。</p>
<p>​    jQuery.fn.extend(object);给jQuery对象添加方法</p>
<p> 3、大部分插件都是用jQuery.fn.extend()</p>
</blockquote>
<h2 id="5-JQuery一个对象可以同时绑定多个事件，这是如何实现的？"><a href="#5-JQuery一个对象可以同时绑定多个事件，这是如何实现的？" class="headerlink" title="5. JQuery一个对象可以同时绑定多个事件，这是如何实现的？"></a>5. JQuery一个对象可以同时绑定多个事件，这是如何实现的？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多个事件同一个函数：</span></span><br><span class="line">	$(<span class="string">"div"</span>).on(<span class="string">"click mouseover"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line"><span class="comment">//多个事件不同函数</span></span><br><span class="line">	$(<span class="string">"div"</span>).on(&#123;</span><br><span class="line">		click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">		mouseover: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="6-ajax实现原理及方法使用"><a href="#6-ajax实现原理及方法使用" class="headerlink" title="6.ajax实现原理及方法使用"></a>6.ajax实现原理及方法使用</h2><blockquote>
<p>readyState属性有五个状态值。</p>
<p>0：是uninitialized，未初始化。已经创建了XMLHttpRequest对象但是未初始化。<br>1：是loading.已经开始准备好要发送了。<br>2：已经发送，但是还没有收到响应。<br>3：正在接受响应，但是还不完整。<br>4：接受响应完毕。<br>responseText：服务器返回的响应文本。只有当readyState&gt;=3的时候才有值，根据readyState的状态值，可以知道，当readyState=3，返回的响应文本不完整，只有readyState=4，完全返回，才能接受全部的响应文本。</p>
<p>responseXML：response  as Dom Document object。响应信息是xml，可以解析为Dom对象。<br>status：服务器的Http状态码，若是200，则表示OK，404，表示为未找到。<br>statusText：服务器http状态码的文本。比如OK，Not Found。</p>
</blockquote>
<h1 id="JS-CSS动画"><a href="#JS-CSS动画" class="headerlink" title="JS CSS动画"></a>JS CSS动画</h1><blockquote>
<p>JS动画</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">　1、过程控制能力强。可以对动画工程进行精准的控制，暂停、取消、开始、终止都可以。</span><br><span class="line">　2、动画效果多、炫酷。有一些效果是CSS动画所不能实现的</span><br><span class="line">　3、兼容性比较高</span><br><span class="line">缺点：</span><br><span class="line">　　　1、由于JS是通过不断的操作DOM和CSS的属性来实现动画效果的，这需要不断的重排（reflow）和重绘（repaint），非常消耗浏览器的内存。（在PC端有浏览器可以分配的内存比较大，动画的重排（reflow）和重绘（repaint）可以忽略不计，但是在移动端效果非常明显）</span><br><span class="line">　　　2、JS动画在主线程中执行，由于主线程中还有其他的JavaScript脚本等需要执行，对主线程进行干扰有可能造成丢帧的问题。</span><br><span class="line">　　　3、较CSS动画复杂</span><br><span class="line">　　　4、由于JS动画的异步处理导致动画开始执行的时间不能准确控制</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CSS动画</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">　　1、浏览器可以进行优化</span><br><span class="line">　　　　如何优化：</span><br><span class="line">　　　　① 浏览器使用与requestAnimationFrame 类似的机制，比起比起setTimeout，setInterval设置动画的优点是</span><br><span class="line">　　　　　*requestAnimationFrame 会把一帧中的所有DOM操作集中起来，在一次重绘或者回流中就完成。并且刷新频率与浏览器相同</span><br><span class="line">　　　　　*在隐藏或不可见的元素中requestAnimationFrame不会进行重绘或者回流，所以会使用更少的CPU GPU和内存使用量</span><br><span class="line">　　　　② 部分属性能够启动3D加速和GPU硬件加速（通过GPU来提高动画性能），例如使用transform的translateZ进行3D变换时</span><br><span class="line">　　2、代码简单，性能调优方向固定。</span><br><span class="line">　　3、对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码</span><br><span class="line">缺点：</span><br><span class="line">　　1、对动画工程无法控制，只能在特定场合暂停取消，不能添加回调函数</span><br><span class="line">　　2、兼容性不好</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="CSS动画比JS流畅的前提"><a href="#CSS动画比JS流畅的前提" class="headerlink" title="CSS动画比JS流畅的前提"></a>CSS动画比JS流畅的前提</h3></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JS在执行一些昂贵的任务</span><br><span class="line">同时CSS动画不触发layout或paint</span><br><span class="line">在CSS动画或JS动画触发了paint或layout时，需要main thread进行Layer树的重计算，这时CSS动画或JS动画都会阻塞后续操作。</span><br><span class="line">只有如下属性的修改才符合“仅触发Composite，不触发layout或paint”：</span><br><span class="line">backface-visibility</span><br><span class="line">opacity</span><br><span class="line">perspective</span><br><span class="line">perspective-origin</span><br><span class="line">transfrom</span><br><span class="line">所以只有用上了3D加速或修改opacity时，css3动画的优势才会体现出来。</span><br><span class="line">     (2)代码相对简单,性能调优方向固定</span><br><span class="line">     (3)对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：所以简单的不需要对中间过程进行过多控制的使用CSS动画；效果交互复杂的使用JS动画</p>
</blockquote>
<h1 id="事件冒泡和事件捕获"><a href="#事件冒泡和事件捕获" class="headerlink" title="事件冒泡和事件捕获"></a>事件冒泡和事件捕获</h1><blockquote>
<p>事件冒泡</p>
</blockquote>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200919182942267.png" alt="image-20200919182942267"></p>
<blockquote>
<p>事件捕获</p>
</blockquote>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200919183002545.png" alt="image-20200919183002545"></p>
<h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><blockquote>
<p>事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件</p>
</blockquote>
<h1 id="轮询、长轮询、长连接和webSocket的区别"><a href="#轮询、长轮询、长连接和webSocket的区别" class="headerlink" title="轮询、长轮询、长连接和webSocket的区别"></a>轮询、长轮询、长连接和webSocket的区别</h1><blockquote>
<p><a href="https://www.cnblogs.com/huchong/p/8595644.html" target="_blank" rel="noopener">https://www.cnblogs.com/huchong/p/8595644.html</a></p>
</blockquote>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>LzMiracle</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/2020/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/">http://yoursite.com/2020/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2020/05/13/Bootstrap4/">Bootstrap4入门</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span style="font-size: 12px">© LzMiracle  | 备案号<a href="https://beian.miit.gov.cn" target="_blank" style="font-size: 12px;color:#bbb;">粤ICP备20007557号</a></span>
    </div>
</footer>

    </div>
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
{% endif %}
</body>
</html>
